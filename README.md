
# 参考

go web编程 

https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/preface.md

go 相关电子书 

https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md#golang


---



go 是一门编译型语言，静态类型语言

将源代码和依赖一起打包，进行静态编译生成本地指令

go的代码是通过package 来组织的

go不支持继承

go的并发有两种 协程、channel,使用消息传递来共享内存。


---

# 名称

- 开头是字母或下划线 
- 关键字不能使用，预置函数不能使用

如果第一个字母的大小写决定是否对包外的可见，包名本身总是小写字母

一般都是驼峰式命名风格

四个主要的声明：var 、 const 、 type 、func


```
var name type = expression
name := expression  // name 的类型由 expression类型决定 ，声明和初始化局部变量

：=  表示声明
= 赋值

```

# 指针

变量是存储值的地方

指针的值是一个变量的地址，使用指针，在不知道变量名的情况下，可以直接或间接的读取或更新变量的值

一个指针指示值所保存的位置，不是所有的值都有地址，但是所有的变量都有。





```
var a int  = 1 
  p = &a  // 表示变量a的地址 ，它的类型是（*int），& 取地址操作符 ， &a 表示获取一个指向整型变量的指针
 *p   //  其实就是使用a 的地址来获取a 的值，也就是 = 1 
```
函数返回局部变量的地址是非常安全的

指针包含变量的地址，传递一个指针给函数，函数可以间接的通过指针修改变量的值

```
& 仅用于生成其操作数对应的地址，也就是用于生成指针会出现在两个内容上：
一个是类型，* Type 这样的格式代表了一个指针类型 
一个是指针，* Pointer 这样的格式用于获取指针所对应的基本值
```

# new 函数

new(T)  //创建一个T类型的变量

每一次调用new返回一个具有唯一地址的变量，地址类型为*T

new是一个预声明的函数不是关键字

```
	p := new(int) //  *int 型的p ，指向未命名的int变量
	*p = 2  // 未命名的int 变量赋值为2 
    // 相当于一个匿名变量
```



# 变量的生命周期
包级别变量的生命周期是整个程序的执行时间

局部变量有一个动态的生命周期：

每次执行声明语句时创建一个新的实体，变量一直生存到它变得不可访问，这时它占用的存储空间被回收。

函数的参数和返回值也是局部变量，他们在闭包函数被调用的时候创建。

变量的生命周期是通过它是否可达来确定的，

var 生命的变量使用的是堆空间，虽然在函数内部但是还可以在其他地方访问

这种情况称为逃逸，变量的每一次逃逸都需要一次额外的内存分配过程

赋值只有在值对于变量类型是可赋值的时才合法


# 类型声明 

type 声明定义一个新的命名类型
```
type name underlying-type 

```

类型的声明通常出现在包级别

对于每个类型T，都有一个对应的类型转换操作T(x)将值x转换为类型T

从字符串转换成字节 slice 会分配一份字符串数据副本。



# 包和文件

每一个包给它的声明提供独立的命名空间

包可以通过控制变量在包外面的可见性或导出情况来隐藏信息

包的初始化从初始化包级别的变量开始，这些变量按照声明顺序初始化

如果包由多个go文件组成，初始化按照编译器收到文件的顺序进行，
go工具会在调用编译器前将go文件排序

这个init函数不能被调用和被引用，程序启动的时候，init函数按照它们声明的顺序自动执行


声明的作用域是指用到声明时所声明名字的源代码段


# 整数

- 有符号整数：int8    int16   int32   int64 
- 无符号整数：uint8   uint16  uint32  uint64

rune类型是int32类型的同义词，指明一个值是unicode码

byte是uint8的同义词，强调一个值是原始数据，而非量值

uintptr 无符号整数，大小不明确，但足以完成存放指针，仅仅用于底层编程

有符号整数以补码表示，保留最高位作为符号位

&   AND

|   OR         

^   XOR

&^  位清空AND NOT

<<  左移
**>>**  右移


#  浮点数
float32     float64


# 复数 
complex64   complex128分别由float32和float64构成

内置的complex函数根据给定的实部和虚部创建复数

内置的real函数和imag函数则分别提取复数的实部和虚部

 
```go
package main
import "fmt"
func f()  {
  x:=complex(1,2)
 	fmt.Println(x) //(1+2i)
 
 	y :=complex(2,3)
 	fmt.Println(y) //(2+3i)
 
 	fmt.Println(x * y ) //(-4+7i)
 
 	fmt.Println(real(x*y)) //-4
 
 	fmt.Println(imag(x*y)) // 7
}
  
```

浮点数或十进制整数后面紧接着写字母i，它就会变成一个虚数


# 字符串

字符串中第i个字节不一定就睡第i个字符

非ASCII字符需要两个字节

下标越界，将触发宕机异常

字符串值无法改变，字符串值本身所包含的字节序列永不可变。

不可变意味着两个字符串能安全地共用同一段底层内存，使得复制任何长度字符串的开销都少


# slice 

表示一个拥有相同类型元素的可变长度的序列，是一种轻量级的数据结构，可以访问数组的部分或者全部元素，这个数组称为slice的底层数组。

指针：指向数组的第一个可以从slice中访问的元素

长度：指slice中元素的个数，不能超过slice的容量

容量：从slice的起始元素到底层数组的最后一个元素间元素的个数

len和cap用来返回slice的长度和容量

一个底层数组可以对应多个slice，slice可以引用数组的任何位置，彼此之间的元素还可以重叠

如果slice的引用超过了被引用对象的容量，cap（s），那么导致程序宕机

slice比较不可以直接使用==，slice的元素是非直接的，可能slice可以包含它自身，如果底层数组元素改变，同一个slice在不同的时间就会有不同的值

不能作为map的键，但是可以==nil ，nil的slice没有对应的底层数组

make([]T ,len）  // slice 只引用了前len个元素

make([]T ,len,cap)  // 创建一个无名数组，并返回了它的一个slice

slice虽然底层数组的元素是间接引用的，但是指针、长度、容量不是


# 结构体

结构体的值可以作为参数传递给函数或者作为函数的返回值，由于效率问题，使用结构体指针的方式直接传递给函数

---


# 函数

```
func name(parameter-list type ) (result-type ){
}
```
函数声明包含  名字、形参列表、返回列表

形参列表：指定了参数名和参数类型

返回列表：指定了返回值的类型

如果几个形参或者返回值的类型相同，那么类型只需要写一次










---

bee执行流程

```
1、main文件监听8080 
2、用户新连接 
3、初始化context 判断类型，WebSocket？
4、执行过滤器 判断是否设置过滤器 ， 有 =》 52 、 没有 =》 51 
51、静态文件处理 
52、执行过滤器AfterStatic 
53、查找固定路由、正则、自动等匹配 
6、执行controller逻辑 
7、过滤器before exec 
8、执行controller init 、 enable XSRF 是否启动跨域 一般都是 beego.Controller 的初始化，不建议用户继承的时候修改该函数 
9、执行controller prepare 一般用户参数初始化 
10、执行controller get/post 
11、执行controller finish 预留给用户用来重写的，用于释放一些资源。释放在 Init 中初始化的信息数据。 
12、执行过滤器 after exec 13、执行controller destructor

是否开启admin 监控统计url

```